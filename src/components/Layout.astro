---
import Header from './Header.astro';
import Footer from './Footer.astro';
import GradientBackground from './GradientBackground.astro';

export interface Props {
    title: string;
    currentPage?: 'about' | 'opportunities' | 'hire-talent' | 'legal';
}

const { title, currentPage } = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>luxsearchÂ® | {title}</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#5e04ed">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="luxsearchÂ®">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="luxsearchÂ®">
    
    <!-- Enhanced Mobile Meta Tags -->
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-TileColor" content="#5e04ed">
    <meta name="msapplication-config" content="/browserconfig.xml">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
    
    <link rel="stylesheet" href="/styles/design-system.css">
    <meta name="view-transition" content="same-origin" />
    <style>
        /* Sticky Footer Layout - maintains design system consistency */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        /* Ensure footer margin doesn't interfere with flex layout */
        .footer {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <GradientBackground />
    <Header currentPage={currentPage} id="navigation" />
    
    <!-- Main Content Area -->
    <main class="main-content" id="main-content">
        <slot />
    </main>

    <!-- Footer -->
    <Footer id="footer" />

    <!-- Job Modal Overlay - Available on all pages -->
    <div id="jobModal" class="job-modal-overlay">
        <div class="job-modal-backdrop"></div>
        <div class="job-modal-content">
            <button class="job-modal-close" aria-label="Close modal">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            
            <!-- Modal content will be populated by JavaScript -->
            <div id="modalJobContent"></div>
        </div>
    </div>

    <!-- Hidden Netlify Form for Callback Requests -->
    <form name="callback-request" data-netlify="true" netlify-honeypot="bot-field" hidden>
        <input type="text" name="name" />
        <input type="tel" name="phone" />
        <input type="email" name="email" />
    </form>

    <!-- Accessibility Skip Links -->
    <div class="skip-links mobile-only">
        <a href="#main-content" class="skip-link">Skip to main content</a>
        <a href="#navigation" class="skip-link">Skip to navigation</a>
        <a href="#footer" class="skip-link">Skip to footer</a>
    </div>

    <!-- Mobile Pull-to-Refresh Indicator -->
    <div class="pull-to-refresh mobile-only">
        <span>ðŸ”„ Pull to refresh</span>
    </div>

    <!-- Accessibility Toolbar -->
    <div class="accessibility-toolbar mobile-only" id="accessibility-toolbar">
        <button class="accessibility-toggle" id="contrast-toggle" title="Toggle High Contrast" aria-label="Toggle High Contrast Mode">
            <span aria-hidden="true">ðŸŒ“</span>
        </button>
        <button class="accessibility-toggle" id="font-size-toggle" title="Increase Font Size" aria-label="Increase Font Size">
            <span aria-hidden="true">ðŸ”¤</span>
        </button>
        <button class="accessibility-toggle" id="voice-commands-toggle" title="Toggle Voice Commands" aria-label="Toggle Voice Command Labels">
            <span aria-hidden="true">ðŸŽ¤</span>
        </button>
        <button class="accessibility-toggle" id="reading-mode-toggle" title="Toggle Reading Mode" aria-label="Toggle Reading Mode">
            <span aria-hidden="true">ðŸ“–</span>
        </button>
    </div>

    <!-- Screen Reader Announcements -->
    <div class="aria-live-region" aria-live="polite" aria-atomic="true" id="announcements"></div>
    <div class="aria-live-region" aria-live="assertive" aria-atomic="true" id="urgent-announcements"></div>

    <script>
        // ðŸš€ 2025 Mobile-First Interactive Experience
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize mobile features first
            initializeMobileInteractions();
            
            // Then initialize SPA navigation
            const navLinks = document.querySelectorAll('.nav-link');
            
            navLinks.forEach(link => {
                link.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const href = link.getAttribute('href');
                    
                    // Immediate visual feedback
                    navLinks.forEach(l => l.classList.remove('current'));
                    
                    // Special handling for logo click - highlight the corresponding nav link instead
                    if (link.classList.contains('logo-link')) {
                        // Find the matching nav link by href and add current class
                        const matchingNavLink = document.querySelector(`.nav .nav-link[href="${href}"]`);
                        if (matchingNavLink) {
                            matchingNavLink.classList.add('current');
                        }
                    } else {
                        link.classList.add('current');
                    }
                    
                    // Use View Transition API if available
                    if ('startViewTransition' in document) {
                        document.startViewTransition(async () => {
                            // Reduce flash by preloading content first
                            const response = await fetch(href);
                            const html = await response.text();
                            const parser = new DOMParser();
                            const newDoc = parser.parseFromString(html, 'text/html');
                            
                            // Quick content swap
                            const newContent = newDoc.querySelector('.main-content');
                            const currentContent = document.querySelector('.main-content');
                            if (newContent && currentContent) {
                                currentContent.innerHTML = newContent.innerHTML;
                                // Re-initialize JavaScript after content replacement
                                initializePageInteractivity();
                            }
                            
                            // Reset scroll and update
                            window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
                            const newTitle = newDoc.querySelector('title');
                            if (newTitle) document.title = newTitle.textContent;
                            history.pushState({}, '', href);
                        });
                    } else {
                        // Smooth fallback
                        const mainContent = document.querySelector('.main-content');
                        mainContent.style.opacity = '0.5';
                        await loadPage(href);
                        mainContent.style.opacity = '1';
                    }
                });
            });

            async function loadPage(url) {
                try {
                    const response = await fetch(url);
                    const html = await response.text();
                    const parser = new DOMParser();
                    const newDoc = parser.parseFromString(html, 'text/html');
                    
                    // Update content
                    const newContent = newDoc.querySelector('.main-content');
                    const currentContent = document.querySelector('.main-content');
                    if (newContent && currentContent) {
                        currentContent.innerHTML = newContent.innerHTML;
                        // Re-initialize JavaScript after content replacement
                        initializePageInteractivity();
                    }
                    
                    // Reset scroll position to top immediately
                    window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
                    
                    // Update title
                    const newTitle = newDoc.querySelector('title');
                    if (newTitle) {
                        document.title = newTitle.textContent;
                    }
                    
                    // Update URL
                    history.pushState({}, '', url);
                    
                } catch (error) {
                    console.error('Navigation error:', error);
                    window.location.href = url;
                }
            }

            // Function to re-initialize page-specific JavaScript functionality
            function initializePageInteractivity() {
                // Re-initialize job card functionality if we're on the opportunities page
                if (document.querySelector('.job-card')) {
                    initializeJobCards();
                }
            }

            // Initialize on first page load
            initializePageInteractivity();
        });

        // Function to initialize job card interactions
        function initializeJobCards() {
            // Job modal functionality
            const jobModal = document.getElementById('jobModal');
            const modalContent = document.getElementById('modalJobContent');
            const closeBtn = document.querySelector('.job-modal-close');
            const backdrop = document.querySelector('.job-modal-backdrop');
            const jobDescriptionsScript = document.getElementById('jobDescriptions');
            
            if (!jobModal || !modalContent || !closeBtn || !backdrop || !jobDescriptionsScript) {
                return; // Exit if required elements don't exist
            }

            const jobDescriptions = JSON.parse(jobDescriptionsScript.textContent);

            // Remove existing event listeners to prevent duplication
            const existingCards = document.querySelectorAll('.job-card');
            existingCards.forEach(card => {
                // Clone node to remove all event listeners
                const newCard = card.cloneNode(true);
                card.parentNode.replaceChild(newCard, card);
            });

            // Add click listeners to job cards
            document.querySelectorAll('.job-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Don't open modal if apply button was clicked
                    if (e.target.closest('.apply-btn')) {
                        return;
                    }
                    
                    const jobId = card.dataset.jobId;
                    if (jobDescriptions[jobId]) {
                        openJobModal(jobDescriptions[jobId]);
                    }
                });
            });

            // Close modal events - only add if not already added
            if (!closeBtn.hasAttribute('data-listener-added')) {
                closeBtn.addEventListener('click', closeJobModal);
                closeBtn.setAttribute('data-listener-added', 'true');
            }

            if (!backdrop.hasAttribute('data-listener-added')) {
                backdrop.addEventListener('click', closeJobModal);
                backdrop.setAttribute('data-listener-added', 'true');
            }

            // Ensure escape key listener is re-registered with the current modal instance
            if (window.__jobEscapeHandler) {
                document.removeEventListener('keydown', window.__jobEscapeHandler);
            }

            window.__jobEscapeHandler = (e) => {
                // Always look up the latest modal element
                const currentModal = document.getElementById('jobModal');
                if (e.key === 'Escape' && currentModal && currentModal.classList.contains('active')) {
                    closeJobModal();
                }
            };

            document.addEventListener('keydown', window.__jobEscapeHandler);
            
            function openJobModal(jobData) {
                // Update URL without page reload
                const jobId = Object.keys(jobDescriptions).find(id => 
                    jobDescriptions[id].title === jobData.title
                );
                if (jobId) {
                    const newUrl = `${window.location.pathname}?job=${jobId}`;
                    window.history.pushState({ jobId }, '', newUrl);
                }
                
                // Create modal content
                modalContent.innerHTML = createModalContent(jobData);
                
                // Add modal functionality
                addModalInteractivity();
                
                // Set the job position in the hidden field
                setTimeout(() => {
                    const jobPositionField = document.getElementById('jobPosition');
                    if (jobPositionField) {
                        jobPositionField.value = jobData.title;
                    }
                }, 10);
                
                // Reset modal scroll position to top - prevents scroll position memory issue
                const modalContainer = document.querySelector('.job-modal-content');
                if (modalContainer) {
                    modalContainer.scrollTop = 0;
                }
                
                // Show modal with animation
                document.body.classList.add('modal-open');
                jobModal.classList.add('active');
            }

            function closeJobModal() {
                // Update URL to remove job parameter
                const urlWithoutJob = window.location.pathname;
                window.history.pushState({}, '', urlWithoutJob);
                
                jobModal.classList.remove('active');
                document.body.classList.remove('modal-open');
            }

            function createModalContent(job) {
                return `
                    <div class="job-modal-header">
                        <h2 class="title">${job.title}</h2>
                        <div class="tags">
                            ${job.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                        <div class="job-details">
                            <span class="salary">${job.salary}</span>
                            <span class="location">${job.location}</span>
                        </div>
                    </div>

                    <div class="job-modal-body">
                        <div class="job-section">
                            <h3 class="subtitle">About this role</h3>
                            <p class="body-text">${job.description.overview}</p>
                        </div>

                        <div class="job-section">
                            <h3 class="subtitle">Key Responsibilities</h3>
                            <ul class="list-bulleted">
                                ${job.description.responsibilities.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                        </div>

                        <div class="job-section">
                            <h3 class="subtitle">Requirements</h3>
                            <ul class="list-bulleted">
                                ${job.description.requirements.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                        </div>

                        <div class="job-section">
                            <h3 class="subtitle">What we offer</h3>
                            <ul class="list-bulleted">
                                ${job.description.benefits.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                        </div>
                    </div>

                    <div class="job-modal-footer">
                        <!-- Hidden form for Netlify detection -->
                        <form name="resume-submission" data-netlify="true" netlify-honeypot="bot-field" hidden>
                            <input type="file" name="resume" />
                            <input type="text" name="position" />
                        </form>

                        <!-- Actual application form -->
                        <form name="resume-submission" id="applicationForm" data-netlify="true" enctype="multipart/form-data" method="POST">
                            <input type="hidden" name="form-name" value="resume-submission" />
                            <input type="hidden" name="position" id="jobPosition" />
                            
                            <!-- Honeypot for bots -->
                            <div style="display: none;">
                                <label>Don't fill this out if you're human: <input name="bot-field" /></label>
                            </div>

                            <div class="application-form">
                                <div class="file-upload-container">
                                    <div class="file-upload-area" id="fileUploadArea">
                                        <div class="file-upload-content">
                                            <svg class="file-upload-icon" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                                <polyline points="7,10 12,15 17,10"></polyline>
                                                <line x1="12" y1="15" x2="12" y2="3"></line>
                                            </svg>
                                            <h4>Drop your CV here or click to browse</h4>
                                            <p class="small-text">PDF, DOC, DOCX</p>
                                        </div>
                                        <input type="file" name="resume" id="cvFile" accept=".pdf,.doc,.docx" required hidden>
                                    </div>
                                    <div class="file-selected" id="fileSelected" style="display: none;">
                                        <span class="file-name" id="fileName"></span>
                                        <button type="button" class="file-remove" id="fileRemove">Ã—</button>
                                    </div>
                                </div>

                                <button type="submit" class="btn btn-submit" id="submitApplication" disabled>
                                    <span>Submit Application</span>
                                </button>

                                <p class="privacy-notice small-text">
                                    By submitting, you accept our <a href="/privacy-policy" class="privacy-link">Privacy Policy</a> and <a href="/terms-of-use" class="privacy-link">Terms of Use</a>.
                                </p>
                            </div>
                        </form>
                    </div>
                `;
            }

            function addModalInteractivity() {
                console.log('[addModalInteractivity] Starting setup...');
                const fileUploadArea = document.getElementById('fileUploadArea');
                const fileInput = document.getElementById('cvFile');
                const fileSelected = document.getElementById('fileSelected');
                const fileName = document.getElementById('fileName');
                const fileRemove = document.getElementById('fileRemove');
                const submitBtn = document.getElementById('submitApplication');
                const applicationForm = document.getElementById('applicationForm');
                console.log('[addModalInteractivity] Elements found:', {fileUploadArea, fileInput, submitBtn});

                // File upload interactions
                fileUploadArea.addEventListener('click', () => fileInput.click());
                fileUploadArea.addEventListener('dragover', handleDragOver);
                fileUploadArea.addEventListener('drop', handleDrop);
                fileInput.addEventListener('change', handleFileSelect);
                fileRemove.addEventListener('click', removeFile);

                function handleDragOver(e) {
                    e.preventDefault();
                    fileUploadArea.classList.add('drag-over');
                }

                function handleDrop(e) {
                    e.preventDefault();
                    fileUploadArea.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFileSelect({ target: { files } });
                    }
                }

                function handleFileSelect(e) {
                    const file = e.target.files[0];
                    if (file) {
                        fileName.textContent = file.name;
                        fileUploadArea.style.display = 'none';
                        fileSelected.style.display = 'flex';
                        
                        // Enable submit button directly
                        const submitBtn = document.getElementById('submitApplication');
                        if (submitBtn) {
                            submitBtn.disabled = false;
                            submitBtn.removeAttribute('disabled');
                            submitBtn.classList.add('btn-submit-active');
                            console.log('Submit button enabled!');
                        }
                    }
                }

                function removeFile() {
                    fileInput.value = '';
                    fileUploadArea.style.display = '';
                    fileSelected.style.display = 'none';
                    updateSubmitButton();
                }

                function updateSubmitButton() {
                    const hasFile = fileInput.files.length > 0;
                    console.log('[updateSubmitButton] hasFile', hasFile, 'disabled(before)', submitBtn.disabled);
                    if (hasFile) {
                        submitBtn.disabled = false;
                        submitBtn.removeAttribute('disabled');
                    } else {
                        submitBtn.disabled = true;
                        submitBtn.setAttribute('disabled', '');
                    }
                    submitBtn.classList.toggle('btn-submit-active', hasFile);
                    console.log('[updateSubmitButton] disabled(after)', submitBtn.disabled);
                }

                // Handle real form submission
                applicationForm.addEventListener('submit', (e) => {
                    if (!fileInput.files.length) {
                        e.preventDefault();
                        alert('Please select a file to upload.');
                        return;
                    }
                    
                    // Form will be submitted normally to Netlify
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<span>Submitting...</span>';
                    
                    // After form submits, redirect to thank-you page
                    setTimeout(() => {
                        window.location.href = '/thank-you';
                    }, 1000);
                });
            }

            // Set up global URL management - make functions globally accessible
            window.__openJobFromUrl = function(jobId) {
                if (jobDescriptions[jobId]) {
                    openJobModal(jobDescriptions[jobId]);
                    return true;
                }
                return false;
            };

            window.__closeJobModal = closeJobModal;
        }

        // Handle browser navigation - set up once globally
        if (!window.__jobNavInitialized) {
            window.__jobNavInitialized = true;
            
            window.addEventListener('popstate', (event) => {
                // Check if we should open a job modal based on URL
                const urlParams = new URLSearchParams(window.location.search);
                const jobId = urlParams.get('job');
                
                if (jobId && window.__openJobFromUrl && window.__openJobFromUrl(jobId)) {
                    // Job opened successfully
                } else {
                    // Close modal if no job in URL or job not found
                    const modal = document.getElementById('jobModal');
                    if (modal && modal.classList.contains('active')) {
                        modal.classList.remove('active');
                        document.body.classList.remove('modal-open');
                    }
                }
            });

            // Check URL on page load to auto-open job if present
            const urlParams = new URLSearchParams(window.location.search);
            const jobId = urlParams.get('job');
            
            if (jobId && window.location.pathname.includes('/opportunities')) {
                // Wait for modal setup to complete
                setTimeout(() => {
                    if (window.__openJobFromUrl) {
                        window.__openJobFromUrl(jobId);
                    }
                }, 100);
            }
        }

        // Callback functionality using existing job modal system
        function initializeCallbackButtons() {
            const callbackButtons = document.querySelectorAll('a[href="#callback"]');
            console.log('Found callback buttons:', callbackButtons.length);
            
            callbackButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Callback button clicked!');
                    openCallbackModal();
                });
            });
        }

        function openCallbackModal() {
            console.log('Opening callback modal...');
            const jobModal = document.getElementById('jobModal');
            const modalContent = document.getElementById('modalJobContent');
            
            console.log('jobModal:', jobModal);
            console.log('modalContent:', modalContent);
            
            if (!jobModal || !modalContent) {
                console.log('Modal elements not found!');
                return;
            }

            // Create callback form content using existing modal structure
            modalContent.innerHTML = createCallbackContent();
            
            // Show modal using existing system
            document.body.classList.add('modal-open');
            jobModal.classList.add('active');
            
            console.log('Modal should be visible now');
            
            // Add callback form functionality
            addCallbackFormInteractivity();
        }

        function createCallbackContent() {
            return `
                <div class="callback-modal-content">
                    <div class="job-modal-header">
                        <h2 class="title">Request a Callback</h2>
                        <p class="body-text">Share your contact details and we'll call you within one working day.</p>
                    </div>

                    <div class="job-modal-footer">
                    <!-- Actual callback form -->
                    <form name="callback-request" id="callbackForm" data-netlify="true" method="POST">
                        <input type="hidden" name="form-name" value="callback-request" />
                        
                        <!-- Honeypot for bots -->
                        <div style="display: none;">
                            <label>Don't fill this out if you're human: <input name="bot-field" /></label>
                        </div>

                        <div class="application-form">
                            <div class="form-group">
                                <label for="callbackName" class="form-label">Name</label>
                                <input type="text" name="name" id="callbackName" class="form-control form-control-gradient" placeholder="Your full name" required>
                            </div>

                            <div class="form-group">
                                <label for="callbackPhone" class="form-label">Phone</label>
                                <input type="tel" name="phone" id="callbackPhone" class="form-control form-control-gradient" placeholder="Your phone number" required>
                            </div>

                            <div class="form-group">
                                <label for="callbackEmail" class="form-label">Email</label>
                                <input type="email" name="email" id="callbackEmail" class="form-control form-control-gradient" placeholder="your.email@example.com" required>
                            </div>

                            <button type="submit" class="btn btn-submit" id="submitCallback" disabled>
                                <span>Request Callback</span>
                            </button>

                            <p class="privacy-notice small-text">
                                By submitting, you agree to our <a href="/privacy-policy" class="privacy-link">Privacy Policy</a> and <a href="/terms-of-use" class="privacy-link">Terms of Use</a>.
                            </p>
                        </div>
                    </form>
                    </div>
                </div>
            `;
        }

                 function addCallbackFormInteractivity() {
             const callbackForm = document.getElementById('callbackForm');
             const submitBtn = document.getElementById('submitCallback');
             const nameInput = document.getElementById('callbackName');
             const phoneInput = document.getElementById('callbackPhone');
             const emailInput = document.getElementById('callbackEmail');
             
             if (!callbackForm || !submitBtn) return;

             // Update submit button state based on form validation - same logic as submitApplication
             function updateSubmitButton() {
                 const isFormValid = nameInput.value.trim() && 
                                   phoneInput.value.trim() && 
                                   emailInput.value.trim() && 
                                   emailInput.checkValidity();
                 
                 if (isFormValid) {
                     submitBtn.disabled = false;
                     submitBtn.removeAttribute('disabled');
                     submitBtn.classList.add('btn-submit-active');
                 } else {
                     submitBtn.disabled = true;
                     submitBtn.setAttribute('disabled', '');
                     submitBtn.classList.remove('btn-submit-active');
                 }
             }

             // Listen to input changes - same pattern as submitApplication
             [nameInput, phoneInput, emailInput].forEach(input => {
                 input.addEventListener('input', updateSubmitButton);
                 input.addEventListener('blur', updateSubmitButton);
             });

             // Initial state check
             updateSubmitButton();

             callbackForm.addEventListener('submit', (e) => {
                 if (!submitBtn.classList.contains('btn-submit-active')) {
                     e.preventDefault();
                     return;
                 }
                 
                 // Form will be submitted normally to Netlify
                 submitBtn.disabled = true;
                 submitBtn.innerHTML = '<span>Submitting...</span>';
                 
                 // After form submits, redirect to thank-you page
                 setTimeout(() => {
                     window.location.href = '/thank-you';
                 }, 1000);
             });
         }

        // Initialize global modal functionality
        function initializeGlobalModal() {
            const jobModal = document.getElementById('jobModal');
            const closeBtn = document.querySelector('.job-modal-close');
            const backdrop = document.querySelector('.job-modal-backdrop');
            
            if (!jobModal) return;

            // Close modal function
            function closeModal() {
                jobModal.classList.remove('active');
                document.body.classList.remove('modal-open');
                
                // Clear URL parameter if it exists
                const urlWithoutJob = window.location.pathname;
                window.history.pushState({}, '', urlWithoutJob);
            }

            // Close button listener
            if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
            }

            // Backdrop click listener
            if (backdrop) {
                backdrop.addEventListener('click', closeModal);
            }

            // ESC key listener
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && jobModal.classList.contains('active')) {
                    closeModal();
                }
            });
        }

        // Initialize callback buttons on page load
        initializeCallbackButtons();
        initializeGlobalModal();

        // Re-initialize after SPA navigation
        const originalInitializePageInteractivity = initializePageInteractivity;
        function initializePageInteractivity() {
            originalInitializePageInteractivity();
            initializeCallbackButtons();
        }

        // ðŸš€ Advanced Mobile Interactions - 2025 Enhancement
        function initializeMobileInteractions() {
            if (window.innerWidth <= 768) {
                initializePullToRefresh();
                initializeTouchGestures();
                initializeHapticFeedback();
                initializeSwipeNavigation();
                initializeMobilePerformanceOptimizations();
            }
        }

        function initializePullToRefresh() {
            const pullToRefreshIndicator = document.querySelector('.pull-to-refresh');
            if (!pullToRefreshIndicator) return;

            let startY = 0;
            let pullDistance = 0;
            let isPulling = false;
            const pullThreshold = 80;

            document.addEventListener('touchstart', (e) => {
                if (window.scrollY === 0) {
                    startY = e.touches[0].clientY;
                    isPulling = true;
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (!isPulling || window.scrollY > 0) return;

                const currentY = e.touches[0].clientY;
                pullDistance = Math.max(0, currentY - startY);

                if (pullDistance > 10) {
                    e.preventDefault();
                    
                    const progress = Math.min(pullDistance / pullThreshold, 1);
                    pullToRefreshIndicator.style.transform = `translateX(-50%) translateY(${Math.min(pullDistance * 0.5, 40)}px)`;
                    pullToRefreshIndicator.style.opacity = progress;

                    if (pullDistance > pullThreshold) {
                        pullToRefreshIndicator.classList.add('active');
                        pullToRefreshIndicator.innerHTML = '<span>ðŸ”„ Release to refresh</span>';
                        simulateHapticFeedback('medium');
                    } else {
                        pullToRefreshIndicator.classList.remove('active');
                        pullToRefreshIndicator.innerHTML = '<span>ðŸ”„ Pull to refresh</span>';
                    }
                }
            });

            document.addEventListener('touchend', () => {
                if (!isPulling) return;
                isPulling = false;

                if (pullDistance > pullThreshold) {
                    // Trigger refresh
                    pullToRefreshIndicator.innerHTML = '<span>âŸ³ Refreshing...</span>';
                    simulateHapticFeedback('heavy');
                    
                    setTimeout(() => {
                        location.reload();
                    }, 800);
                } else {
                    // Reset
                    pullToRefreshIndicator.style.transform = 'translateX(-50%) translateY(-100%)';
                    pullToRefreshIndicator.style.opacity = '0';
                    pullToRefreshIndicator.classList.remove('active');
                }

                pullDistance = 0;
            });
        }

        function initializeTouchGestures() {
            // Add swipe detection for cards
            document.querySelectorAll('.card').forEach(card => {
                let startX = 0;
                let startY = 0;
                let startTime = 0;

                card.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                });

                card.addEventListener('touchend', (e) => {
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const endTime = Date.now();

                    const deltaX = endX - startX;
                    const deltaY = endY - startY;
                    const deltaTime = endTime - startTime;

                    // Detect swipe gestures
                    if (Math.abs(deltaX) > 50 && Math.abs(deltaY) < 100 && deltaTime < 300) {
                        if (deltaX > 0) {
                            // Swipe right - could trigger a specific action
                            card.style.transform = 'translateX(10px)';
                            setTimeout(() => card.style.transform = '', 150);
                            simulateHapticFeedback('light');
                        } else {
                            // Swipe left - could trigger another action
                            card.style.transform = 'translateX(-10px)';
                            setTimeout(() => card.style.transform = '', 150);
                            simulateHapticFeedback('light');
                        }
                    }
                });
            });

            // Add pinch-to-zoom detection for images
            document.querySelectorAll('img').forEach(img => {
                let initialPinchDistance = 0;

                img.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        initialPinchDistance = Math.hypot(
                            touch1.clientX - touch2.clientX,
                            touch1.clientY - touch2.clientY
                        );
                    }
                });

                img.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch1.clientX - touch2.clientX,
                            touch1.clientY - touch2.clientY
                        );

                        const scale = currentDistance / initialPinchDistance;
                        if (scale > 1.1) {
                            img.style.transform = `scale(${Math.min(scale, 2)})`;
                            simulateHapticFeedback('light');
                        }
                    }
                });

                img.addEventListener('touchend', () => {
                    img.style.transform = '';
                });
            });
        }

        function initializeHapticFeedback() {
            // Add haptic feedback to interactive elements
            document.querySelectorAll('.btn, .job-card, .nav-link, .tag').forEach(element => {
                element.addEventListener('touchstart', () => {
                    element.classList.add('haptic-light');
                    simulateHapticFeedback('light');
                });

                element.addEventListener('touchend', () => {
                    setTimeout(() => element.classList.remove('haptic-light'), 150);
                });
            });

            // Stronger feedback for primary buttons
            document.querySelectorAll('.btn-primary, .btn-cta, .btn-submit-active').forEach(element => {
                element.addEventListener('touchstart', () => {
                    element.classList.add('haptic-medium');
                    simulateHapticFeedback('medium');
                });

                element.addEventListener('touchend', () => {
                    setTimeout(() => element.classList.remove('haptic-medium'), 150);
                });
            });
        }

        function initializeSwipeNavigation() {
            let startX = 0;
            let startY = 0;

            document.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            });

            document.addEventListener('touchend', (e) => {
                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                const deltaX = endX - startX;
                const deltaY = Math.abs(endY - startY);

                // Detect edge swipe for navigation
                if (startX < 50 && deltaX > 100 && deltaY < 100) {
                    // Swipe from left edge - could trigger back navigation
                    const currentPath = window.location.pathname;
                    if (currentPath === '/hire-talent') {
                        navigateWithTransition('/');
                    } else if (currentPath === '/') {
                        navigateWithTransition('/hire-talent');
                    }
                    simulateHapticFeedback('medium');
                }
            });
        }

        function initializeMobilePerformanceOptimizations() {
            // Intersection Observer for lazy loading
            const observerOptions = {
                rootMargin: '50px',
                threshold: 0.1
            };

            const imageObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            imageObserver.unobserve(img);
                        }
                    }
                });
            }, observerOptions);

            // Observe all images with data-src
            document.querySelectorAll('img[data-src]').forEach(img => {
                imageObserver.observe(img);
            });

            // Add loading skeletons for slow content
            const slowElements = document.querySelectorAll('.card, .job-card');
            slowElements.forEach(element => {
                element.classList.add('loading-skeleton');
                setTimeout(() => {
                    element.classList.remove('loading-skeleton');
                }, 100);
            });

            // Optimize scroll performance
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                document.body.classList.add('scrolling');
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    document.body.classList.remove('scrolling');
                }, 150);
            });
        }

        function navigateWithTransition(url) {
            document.body.classList.add('page-transition-exit');
            setTimeout(() => {
                window.location.href = url;
            }, 200);
        }

        function simulateHapticFeedback(intensity = 'light') {
            if (navigator.vibrate) {
                const patterns = {
                    light: 10,
                    medium: [10, 10, 10],
                    heavy: [15, 10, 15, 10, 15]
                };
                navigator.vibrate(patterns[intensity] || patterns.light);
            }
        }

        // ðŸš€ PWA Service Worker Registration
        function initializePWA() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('âœ… Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        // New version available - could show update notification
                                        console.log('ðŸ”„ New version available! Refresh to update.');
                                        showUpdateNotification();
                                    }
                                });
                            }
                        });
                    })
                    .catch(error => {
                        console.error('âŒ Service Worker registration failed:', error);
                    });

                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data && event.data.type === 'SKIP_WAITING') {
                        window.location.reload();
                    }
                });
            }

            // PWA install prompt
            let deferredPrompt;
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                showInstallPrompt();
            });

            // Handle app installed
            window.addEventListener('appinstalled', (evt) => {
                console.log('ðŸ“± PWA was installed successfully');
                hideInstallPrompt();
                simulateHapticFeedback('heavy');
            });
        }

        function showUpdateNotification() {
            // Create a subtle update notification
            const updateBanner = document.createElement('div');
            updateBanner.className = 'update-notification mobile-only';
            updateBanner.innerHTML = `
                <div class="update-content">
                    <span>ðŸ†• New version available!</span>
                    <button onclick="location.reload()" class="btn-update">Update</button>
                </div>
            `;
            document.body.appendChild(updateBanner);

            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (updateBanner.parentNode) {
                    updateBanner.remove();
                }
            }, 5000);
        }

        function showInstallPrompt() {
            // Show PWA install prompt on mobile only
            if (window.innerWidth <= 768 && !window.matchMedia('(display-mode: standalone)').matches) {
                const installBanner = document.createElement('div');
                installBanner.className = 'install-prompt mobile-only';
                installBanner.innerHTML = `
                    <div class="install-content">
                        <span>ðŸ“± Install luxsearchÂ® app for better experience</span>
                        <button onclick="installPWA()" class="btn-install">Install</button>
                        <button onclick="hideInstallPrompt()" class="btn-dismiss">Ã—</button>
                    </div>
                `;
                document.body.appendChild(installBanner);

                // Auto-hide after 10 seconds
                setTimeout(() => {
                    hideInstallPrompt();
                }, 10000);
            }
        }

        function hideInstallPrompt() {
            const installPrompt = document.querySelector('.install-prompt');
            if (installPrompt) {
                installPrompt.remove();
            }
        }

        // Global function for install button
        window.installPWA = function() {
            const installPrompt = document.querySelector('.install-prompt');
            if (deferredPrompt && installPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('ðŸ‘ User accepted the install prompt');
                        simulateHapticFeedback('heavy');
                    } else {
                        console.log('ðŸ‘Ž User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                    hideInstallPrompt();
                });
            }
        };

        // Initialize PWA features
        initializePWA();

        // Initialize accessibility features
        initializeAccessibility();

        // ðŸš€ Comprehensive Mobile Accessibility System
        function initializeAccessibility() {
            // Detect keyboard navigation
            detectKeyboardNavigation();
            
            // Initialize accessibility toolbar
            initializeAccessibilityToolbar();
            
            // Setup focus management
            setupFocusManagement();
            
            // Initialize screen reader announcements
            initializeScreenReaderAnnouncements();
            
            // Setup touch accessibility
            setupTouchAccessibility();
            
            // Initialize voice commands
            initializeVoiceCommands();
            
            // Detect and adapt to accessibility preferences
            detectAccessibilityPreferences();
            
            console.log('â™¿ Accessibility features initialized');
        }

        function detectKeyboardNavigation() {
            let isKeyboardNavigation = false;
            
            // Detect keyboard usage
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    isKeyboardNavigation = true;
                    document.body.classList.add('keyboard-navigation');
                }
            });
            
            // Detect mouse usage
            document.addEventListener('mousedown', () => {
                if (isKeyboardNavigation) {
                    isKeyboardNavigation = false;
                    document.body.classList.remove('keyboard-navigation');
                }
            });
            
            // Detect touch usage
            document.addEventListener('touchstart', () => {
                if (isKeyboardNavigation) {
                    isKeyboardNavigation = false;
                    document.body.classList.remove('keyboard-navigation');
                }
            });
        }

        function initializeAccessibilityToolbar() {
            const toolbar = document.getElementById('accessibility-toolbar');
            const contrastToggle = document.getElementById('contrast-toggle');
            const fontSizeToggle = document.getElementById('font-size-toggle');
            const voiceCommandsToggle = document.getElementById('voice-commands-toggle');
            const readingModeToggle = document.getElementById('reading-mode-toggle');
            
            // Show toolbar on mobile
            if (window.innerWidth <= 768) {
                setTimeout(() => {
                    toolbar.classList.add('visible');
                }, 1000);
            }
            
            // High contrast toggle
            contrastToggle.addEventListener('click', () => {
                document.body.classList.toggle('high-contrast');
                contrastToggle.classList.toggle('active');
                announceToScreenReader('High contrast mode ' + 
                    (document.body.classList.contains('high-contrast') ? 'enabled' : 'disabled'));
                simulateHapticFeedback('light');
            });
            
            // Font size toggle
            let fontSizeLevel = 0;
            fontSizeToggle.addEventListener('click', () => {
                fontSizeLevel = (fontSizeLevel + 1) % 4;
                document.body.classList.remove('font-size-1', 'font-size-2', 'font-size-3');
                
                if (fontSizeLevel > 0) {
                    document.body.classList.add(`font-size-${fontSizeLevel}`);
                    fontSizeToggle.classList.add('active');
                } else {
                    fontSizeToggle.classList.remove('active');
                }
                
                announceToScreenReader(`Font size level ${fontSizeLevel}`);
                simulateHapticFeedback('light');
            });
            
            // Voice commands toggle
            voiceCommandsToggle.addEventListener('click', () => {
                document.body.classList.toggle('voice-commands-visible');
                voiceCommandsToggle.classList.toggle('active');
                announceToScreenReader('Voice command labels ' + 
                    (document.body.classList.contains('voice-commands-visible') ? 'shown' : 'hidden'));
                simulateHapticFeedback('light');
            });
            
            // Reading mode toggle
            readingModeToggle.addEventListener('click', () => {
                document.body.classList.toggle('reading-mode');
                readingModeToggle.classList.toggle('active');
                announceToScreenReader('Reading mode ' + 
                    (document.body.classList.contains('reading-mode') ? 'enabled' : 'disabled'));
                simulateHapticFeedback('light');
            });
        }

        function setupFocusManagement() {
            // Trap focus in modals
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                modal.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        trapFocus(modal, e);
                    }
                    if (e.key === 'Escape') {
                        closeModal(modal);
                    }
                });
            });
            
            // Manage focus for hamburger menu
            const hamburger = document.querySelector('.hamburger-menu');
            const mobileNav = document.querySelector('.mobile-nav');
            
            if (hamburger && mobileNav) {
                hamburger.addEventListener('click', () => {
                    const isExpanded = hamburger.getAttribute('aria-expanded') === 'true';
                    hamburger.setAttribute('aria-expanded', !isExpanded);
                    
                    if (!isExpanded) {
                        // Focus first menu item when opened
                        setTimeout(() => {
                            const firstLink = mobileNav.querySelector('a');
                            if (firstLink) firstLink.focus();
                        }, 100);
                    }
                });
            }
        }

        function trapFocus(element, event) {
            const focusableElements = element.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];
            
            if (event.shiftKey) {
                if (document.activeElement === firstElement) {
                    lastElement.focus();
                    event.preventDefault();
                }
            } else {
                if (document.activeElement === lastElement) {
                    firstElement.focus();
                    event.preventDefault();
                }
            }
        }

        function initializeScreenReaderAnnouncements() {
            const announcements = document.getElementById('announcements');
            const urgentAnnouncements = document.getElementById('urgent-announcements');
            
            // Global function to announce to screen readers
            window.announceToScreenReader = function(message, urgent = false) {
                const region = urgent ? urgentAnnouncements : announcements;
                region.textContent = message;
                
                // Clear after announcement
                setTimeout(() => {
                    region.textContent = '';
                }, 1000);
            };
            
            // Announce page changes
            window.addEventListener('pageshow', () => {
                announceToScreenReader('Page loaded');
            });
            
            // Announce form errors
            document.addEventListener('submit', (e) => {
                const form = e.target;
                const errors = form.querySelectorAll('.error, [aria-invalid="true"]');
                
                if (errors.length > 0) {
                    announceToScreenReader(`Form has ${errors.length} error${errors.length > 1 ? 's' : ''}`, true);
                }
            });
        }

        function setupTouchAccessibility() {
            // Add touch indicators for interactive elements
            const interactiveElements = document.querySelectorAll('button, a, [role="button"]');
            
            interactiveElements.forEach(element => {
                element.addEventListener('touchstart', () => {
                    element.classList.add('touch-active');
                    simulateHapticFeedback('light');
                });
                
                element.addEventListener('touchend', () => {
                    setTimeout(() => {
                        element.classList.remove('touch-active');
                    }, 150);
                });
            });
            
            // Double-tap to activate for users with motor disabilities
            let lastTouchTime = 0;
            let lastTouchTarget = null;
            
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                const target = e.target;
                
                if (now - lastTouchTime < 300 && target === lastTouchTarget) {
                    // Double tap detected
                    if (target.tagName === 'A') {
                        target.click();
                    } else if (target.tagName === 'BUTTON') {
                        target.click();
                    }
                    announceToScreenReader('Double tap activated');
                    simulateHapticFeedback('medium');
                }
                
                lastTouchTime = now;
                lastTouchTarget = target;
            });
        }

        function initializeVoiceCommands() {
            // Add voice command attributes to key elements
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach((link, index) => {
                link.setAttribute('data-voice-command', `Go to ${link.textContent.trim()}`);
            });
            
            const buttons = document.querySelectorAll('.btn');
            buttons.forEach((button, index) => {
                const text = button.textContent.trim();
                button.setAttribute('data-voice-command', `Click ${text}`);
            });
            
            // Add voice command for hamburger menu
            const hamburger = document.querySelector('.hamburger-menu');
            if (hamburger) {
                hamburger.setAttribute('data-voice-command', 'Open menu');
            }
        }

        function detectAccessibilityPreferences() {
            // Detect and apply system preferences
            
            // High contrast preference
            if (window.matchMedia('(prefers-contrast: high)').matches) {
                document.body.classList.add('high-contrast');
                document.getElementById('contrast-toggle').classList.add('active');
            }
            
            // Reduced motion preference
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.body.classList.add('reduced-motion');
                announceToScreenReader('Reduced motion mode detected');
            }
            
            // Color scheme preference
            if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.body.classList.add('dark-mode');
            }
            
            // Listen for changes
            window.matchMedia('(prefers-contrast: high)').addEventListener('change', (e) => {
                if (e.matches) {
                    document.body.classList.add('high-contrast');
                    document.getElementById('contrast-toggle').classList.add('active');
                } else {
                    document.body.classList.remove('high-contrast');
                    document.getElementById('contrast-toggle').classList.remove('active');
                }
            });
            
            window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
                if (e.matches) {
                    document.body.classList.add('reduced-motion');
                    announceToScreenReader('Reduced motion mode enabled');
                } else {
                    document.body.classList.remove('reduced-motion');
                    announceToScreenReader('Reduced motion mode disabled');
                }
            });
        }
    </script>
</body>
</html> 